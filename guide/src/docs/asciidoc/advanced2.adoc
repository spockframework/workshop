= Advanced 2 - Parallel Execution

NOTE: This part assumes you've completed <<_advanced1.adoc#_advanced1, Advanced 1>>,
      while the knowledge from that module is not strictly necessary the result is used in this module.
      If you directly want to start with this module you can take the code from the solution branch.


This workshop module teaches you about Spocks support for parallel execution.
You should have a basic understanding about Spock (check the basic workshop).

Learning Goals:

* You know about and can configure the parallel execution settings in `SpockConfig.groovy`
* You know when to use `@Execution`, `@ResourceLock`, `@Isolated`


NOTE: Maven Surefire 3.0.0-M5 has an issue with reporting in parallel execution https://issues.apache.org/jira/browse/SUREFIRE-1643[SUREFIRE-1643]
      `JUnit 5 in parallel execution mode confuses Surefire reports`
      this can lead to wrong reports where feature are reported to be in a wrong specification.
      For the time being it might be better to execute the tests using IntelliJ

== Step 1

Add the advanced1 project as dependency to get access to the `ExecutionLogExtension`.
Run all tests (either `../mvnw verify` or via IntelliJ) and look at the generated execution record.


NOTE: The main code and tests are contrived to demonstrate issues that can lurk in code with shared state.
      Don't change the main implementation and features themselves, you should only use the extensions mentioned in Step 3.

== Step 2

Enable parallel execution by creating `src/test/resources/SpockConfig.groovy` with

[source,groovy]
----
runner {
    parallel {
        enabled true
        fixed(16)
    }
}
----

see also http://spockframework.org/spock/docs/2.0/parallel_execution.html#parallel-thread-pool[Parallel Thread Pool].

Run all tests 2x and compare the generated execution records.

Notice that tests started failing when executed in parallel.

You can experiment with the different thread pool options but continue with `fixed(16)`.


NOTE: Sometimes IntelliJ does not correctly copy the resources,
      if you don't see an effect in IntelliJ copy the `SpockConfig.groovy` to `target/test-classes` manually.

== Step 3
Look at the tools Spock gives you to deal with tests that use a shared resource.

* http://spockframework.org/spock/docs/2.0/parallel_execution.html#execution-modes[Execution modes]
* http://spockframework.org/spock/docs/2.0/parallel_execution.html#_resource_locks[Resource Locks]
* http://spockframework.org/spock/docs/2.0/parallel_execution.html#_isolated_execution[Isolated Execution]
* Some http://spockframework.org/spock/docs/2.0/extensions.html[Extension] also affect parallel execution, you can find that info in the notes

== Step 4

Most of the time tests fail, because they have shared state be it global variables, singletons, system properties, or something else.
Your task is to identify those shared states and apply the tools you've learned about in Step 3 to fix the failing tests.

There are several ways to approach this problem.

=== Go Specification by Specification in IntelliJ
This will help you to solve problems inside a specification.

=== Enable parallel execution one by one
With this setting both the specifications and features will run sequentially by default.
You can now selectively enable concurrent execution by annotating the specifications one by one with `@Execution(ExecutionMode.CONCURRENT)`,
while executing all tests.

[source,groovy]
----
import org.spockframework.runtime.model.parallel.ExecutionMode

runner {
    parallel {
        enabled true
        fixed(16)
        defaultExecutionMode ExecutionMode.SAME_THREAD
        defaultSpecificationExecutionMode ExecutionMode.SAME_THREAD
    }
}
----

NOTE: Both Spock and JUnit Jupiter have an `@Execution` extension,
      make sure you use the one from Spock `import spock.lang.Execution`.


== Step 5

Optimize the amount of concurrency. The easiest solution would be to just disable parallel execution altogether or use `@Isolated` for every specification,
but that defeats the purpose. Try to use read-locks as much as possible and only use write locks where you actually mutate shared state.
Also keep the http://spockframework.org/spock/docs/2.0/parallel_execution.html#_lock_coarsening[lock coarsening] behavior in mind when applying locks.
